# Ficha técnica Diseño de Aplicaciones 2 (Dictado S1 2025) 

**Carrera:** 

Ingeniería en Sistemas (6to semestre) / Licenciatura en Sistemas (5to semestre) 

**Descripción:**

Durante este curso se profundiza y aplican los conceptos estudiados en el curso Diseño de aplicaciones 1 mediante la introducción de conceptos avanzados de análisis y diseño. Se expondrá al estudiante a las arquitecturas cliente-servidor y al diseño centrado en las Interfaces de programación de aplicaciones, haciendo énfasis en la separación de intereses en las capas de presentación, servicios y acceso a datos. A su vez se introducen el diseño de frameworks, se profundiza en la utilización de principios de diseño sustentados mediante análisis de métricas a nivel de código y diseño. Se utilizan diversas tecnologías para el desarrollo de interfaces de usuario ricas, servicios web y tecnologías de persistencia de datos. 

**Metodología:** 

3 horas semanales de clases teóricas + 2 horas semanales de clase prácticas 

**Conocimientos previos:** 

- Estructuras de datos y algoritmos 1:
    - Diseño de algoritmos iterativos basado en invariantes. Noción de invariante. Método general de diseño. Técnicas de diseño de invariantes.  
    - Análisis de algoritmos. Noción de orden y tasa de crecimiento. 
    - Tipos abstractos de datos. Noción general. Pilas y colas. Implementación mediante estructuras dinámicas: punteros.
    - Recursión. Lineal y en árboles. Eliminación de la recursión mediante el uso de pilas.  
    - Ordenamiento. Algoritmos de ordenamiento de estructuras lineales.  
    - Búsqueda. Tablas y algunas de sus implementaciones.
    - Grafos. Representación. Recorrida. Problemas de optimización.  

- Fundamentos de Ingeniería de Software:  
    - Introducción a IS 
    - SCM y versionado con Git 
    - Ingeniería de Requerimientos 
    - Interfaz de usuario 
    - Codificación y test unitario. Buenas prácticas. Linters. 
    - Testing funcional 
    - Stack tecnológico: JS, Jest, Git, GitHub 

 - Bases de datos 1: 
    - Conceptos básicos: Introducción a los sistemas de bases de datos. Evolución de los SGBD (Sistemas Gerenciadores de Bases de Datos). Objetivos, funciones y estructuras de los SGBD.  
    - Introducción al diseño conceptual de bases de datos: Modelo Entidad-Relación extendido. Modelo Relacional. 
    - Lenguajes de consulta: Álgebra relacional, cálculo relacional de tuplas y SQL.  
    - Diseño relacional: Dependencias funcionales y multivaluadas. Formas Normales 

- Programación 2:  
    - Nociones de orientación a objetos. Modularidad, re-uso, encapsulación.  
    - Nociones de análisis y diseño orientado a objetos. Concepto de dominio del problema e interfaz de usuario.  
    - Conceptos básicos de orientación a objetos: Clases, objetos. Mensajes, métodos. Jerarquía de clases. Relaciones: Asociación, Agregación, Herencia. Concepto de “this” y “super”.  
    - Polimorfismo. Copia de objetos. Igualdad e identidad. 
    - Notación UML.  
    - Conceptos de Programación: Parámetros. Matrices. Manejo avanzado de colecciones.  
    - Depuración de programas. Uso de estándares y estilo de programación.
    - Excepciones: manejo y propagación.
    - Interfaz gráfica.
    - Manejo de persistencia.
    - Java/NetBeans (IDE) 

- Diseño de Aplicaciones 1 
    - El análisis y diseño en el marco del ciclo de vida del desarrollo.
    - Prácticas de código orientado a la mantenibilidad.
    - Modelos de análisis y diseño y su representación en la notación UML.
    - Diseño de software basado en el comportamiento.
    - Impacto de la herencia, la utilización de interfaces y polimorfismo en el diseño.
    - Introducción a los principios y guías de diseño a nivel de clase.
    - Introducción a los Patrones de diseño.
    - Desarrollo guiado por las pruebas y técnicas de refactoreo de código.
    - Tecnologías de persistencia de objetos en Bases de datos relacionales.
    - Diseño básico de Interfaces de usuario en función de las tecnologías de presentación.
      
**Contenidos**

  - Análisis avanzado de requerimientos y modelado del dominio del problema.  
  - Modelos y vistas de las arquitecturas de software, notación UML avanzada   
  - Introducción a los frameworks de software.  
  - Patrones de arquitectura asociados al diseño de aplicaciones cliente-servidor.  
  - Elementos de las arquitecturas web y distribuidas. Diseño de interfaz de programación de aplicaciones (API) y conectores avanzados: servicios web REST, invocación remota y colas de mensajes.  
  - Aplicación de patrones de diseño al desarrollo de lógica de presentación y lógica de negocios.  
  - Aspectos de seguridad y eficiencia en aplicaciones cliente - servidor.  
  - Elementos de las interfaces de usuario web e interfaces ricas.  
  - Las arquitecturas cliente servidor en contextos de computación ubicua.  
  - Mejora de la calidad del diseño. Aplicación de principios de diseño a nivel de clase y paquetes. Utilización de métricas de diseño para evaluar la calidad del producto. 

**Tecnologías/herramientas utilizadas:**  

- .NET 8.0 / C# 
- Angular (La versión más reciente y más estable, no está definida a nivel requerimientos)
- Git/GitHub 
- Entity Framework 
- SQL - Azure 

**Conocimientos de virtualización/ Cloud:**

- Docker:  
    - Estudiantes de Ingeniería (Posibilidad de que en el 4to semestre hayan cursado Sistemas Operativos): Sí
    - Estudiantes de Licenciatura (Existe la posibilidad de que en simultaneo cursen Infraestructura, del 4to semestre de la carrera). 

**Forma de evaluación:**

- Cuestionarios 
- Parcial final 
- Obligatorio
     – Proyecto integrador en el que el estudiante deberá llevar a cabo un proyecto de software de pequeña escala, desde la etapa de Ingeniería de Requerimientos, hasta la etapa de Pruebas. 

**Motivación Cloud**
- Disponibilidad como atributo de calidad. 
- Ejemplo práctico para profundizar la vista de despliegue del modelo 4+1
- Comprender la base de datos, el Frontend y el Backend como componentes separados
- Portafolio. Posibilidad de que el estudiante pueda mostrar el trabajo realizado a lo largo de todo el semestre. 
- Testing en un ambiente desligado al hardware del alumno 


 

 

 
